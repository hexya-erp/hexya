// Copyright 2019 NDP SystÃ¨mes. All Rights Reserved.
// See LICENSE file for full licensing details.

package generate

import "text/template"

var poolQueryTemplate = template.Must(template.New("").Parse(`
// This file is autogenerated by hexya-generate
// DO NOT MODIFY THIS FILE - ANY CHANGES WILL BE OVERWRITTEN

package {{ .QueryPackageName }}

import (
	"github.com/hexya-erp/hexya/src/models"
	"github.com/hexya-erp/pool/{{ .QueryPackageName }}/{{ .SnakeName }}"
)

type {{ .Name }}Condition = {{ .SnakeName }}.Condition

// {{ .Name }} returns a {{ .SnakeName }}.ConditionStart for {{ .Name }}Model
func {{ .Name }}() {{ .SnakeName }}.ConditionStart {
	return {{ .SnakeName }}.ConditionStart{
		ConditionStart: &models.ConditionStart{},
	}
}
`))

var poolModelsQueryTemplate = template.Must(template.New("").Parse(`
// This file is autogenerated by hexya-generate
// DO NOT MODIFY THIS FILE - ANY CHANGES WILL BE OVERWRITTEN

package {{ .SnakeName }}

import (
	"github.com/hexya-erp/hexya/src/models/operator"
	"github.com/hexya-erp/hexya/src/models"
{{ range .TypesDeps }} 	"{{ . }}"
{{ end }}
)

// ------- INTERFACES --------

{{ range .RelModels }}
type {{ . }}Condition interface {
	models.Conditioner
	{{ . }}ConditionHexyaFunc()
}

type {{ . }}Set interface {
	models.RecordSet
	{{ . }}SetHexyaFunc()
}
{{ end }}

// ------- CONDITION ---------

// A Condition is a type safe WHERE clause in an SQL query
type Condition struct {
	*models.Condition
}

{{ range .ConditionFuncs }}
// {{ . }} completes the current condition with a simple {{ . }} clause : c.{{ . }}().nextCond => c {{ . }} nextCond
//
// No brackets are added so AND precedence over OR applies.
func (c Condition) {{ . }}() ConditionStart {
	return ConditionStart{
		ConditionStart: c.Condition.{{ . }}(),
	}
}

// {{ . }}Cond completes the current condition with the given cond as an {{ . }} clause
// between brackets : c.{{ . }}(cond) => c {{ . }} (cond)
func (c Condition) {{ . }}Cond(cond Condition) Condition {
	return Condition{
		Condition: c.Condition.{{ . }}Cond(cond.Condition),
	}
}
{{ end }}

// Underlying returns the underlying models.Condition instance
func (c Condition) Underlying() *models.Condition {
	return c.Condition
}

// {{ $.Name }}ConditionHexyaFunc is a dummy function to uniquely match interfaces.
func (c Condition) {{ $.Name }}ConditionHexyaFunc() {}

var _ models.Conditioner = Condition{}

// ------- CONDITION START ---------

// A ConditionStart is an object representing a Condition when
// we just added a logical operator (AND, OR, ...) and we are
// about to add a predicate.
type ConditionStart struct {
	*models.ConditionStart
}

// NewCondition returns a valid empty Condition
func (cs ConditionStart) NewCondition() Condition {
	return Condition {
		Condition: &models.Condition{},
	}
}

{{ range .Fields }}
// {{ .Name }} adds the "{{ .Name }}" field to the Condition
func (cs ConditionStart) {{ .Name }}() p{{ .SanType }}ConditionField {
	return p{{ .SanType }}ConditionField{
		ConditionField: cs.Field("{{ .Name }}"),
	}
}

{{ if .IsRS }}
// {{ .Name }}FilteredOn adds a condition with a table join on the given field and
// filters the result with the given condition
func (cs ConditionStart) {{ .Name }}FilteredOn(cond {{ .RelModel }}Condition) Condition {
	return Condition{
		Condition: cs.FilteredOn("{{ .Name }}", cond.Underlying()),
	}
}
{{ end }}
{{ end }}

// ------- CONDITION FIELDS ----------

{{ range $typ := .Types }}
// A p{{ $typ.SanType }}ConditionField is a partial Condition when
// we have selected a field of type {{ $typ.Type }} and expecting an operator.
type p{{ $typ.SanType }}ConditionField struct {
	*models.ConditionField
}

{{ range $typ.Operators }}
// {{ .Name }} adds a condition value to the ConditionPath
func (c p{{ $typ.SanType }}ConditionField) {{ .Name }}(arg {{ if and .Multi (not $typ.IsRS) }}[]{{ end }}{{ $typ.Type }}) Condition {
	return Condition{
		Condition: c.ConditionField.{{ .Name }}(arg),
	}
}

// {{ .Name }}Func adds a function value to the ConditionPath.
// The function will be evaluated when the query is performed and
// it will be given the RecordSet on which the query is made as parameter
func (c p{{ $typ.SanType }}ConditionField) {{ .Name }}Func(arg func (models.RecordSet) {{ if and .Multi (not $typ.IsRS) }}[]{{ end }}{{ if $typ.IsRS }}models.RecordSet{{ else }}{{ $typ.Type }}{{ end }}) Condition {
	return Condition{
		Condition: c.ConditionField.{{ .Name }}(arg),
	}
}

// {{ .Name }}Eval adds an expression value to the ConditionPath.
// The expression value will be evaluated by the client with the
// corresponding execution context. The resulting Condition cannot
// be used server-side.
func (c p{{ $typ.SanType }}ConditionField) {{ .Name }}Eval(expression string) Condition {
	return Condition{
		Condition: c.ConditionField.{{ .Name }}(models.ClientEvaluatedString(expression)),
	}
}

{{ end }}

// IsNull checks if the current condition field is null
func (c p{{ $typ.SanType }}ConditionField) IsNull() Condition {
	return Condition{
		Condition: c.ConditionField.IsNull(),
	}
}

// IsNotNull checks if the current condition field is not null
func (c p{{ $typ.SanType }}ConditionField) IsNotNull() Condition {
	return Condition{
		Condition: c.ConditionField.IsNotNull(),
	}
}

// AddOperator adds a condition value to the condition with the given operator and data
// If multi is true, a recordset will be converted into a slice of int64
// otherwise, it will return an int64 and panic if the recordset is not a singleton.
//
// This method is low level and should be avoided. Use operator methods such as Equals() instead.
func (c p{{ $typ.SanType }}ConditionField) AddOperator(op operator.Operator, data interface{}) Condition {
	return Condition{
		Condition: c.ConditionField.AddOperator(op, data),
	}
}

{{ end }}

`))
